install.packages("binom")
library(binom)
set.seed(0)
nsims <- 10000
maxn <- 500
n <- seq(2,maxn, by=2)
my.method <- c("exact", "ac", "asymptotic", "wilson", "prop.test", "bayes", "logit", "cloglog", "probit")
my.method <- my.method[sort.list(my.method)]
coverage <- matrix(NA, nrow=length(n), ncol=length(my.method))
ci.lower <- ci.upper <- matrix(NA, ncol=length(my.method), nrow=length(n))
for(i in 1:length(n)){
m <- n[i]/2
y <- rbinom(nsims, n[i], m/n[i])
ll <- binom.confint(m,n[i], conf.level=.95, method=my.method)$lower
ul <- binom.confint(m,n[i], conf.level=.95, method=my.method)$upper
ci.lower[i,] <- ll
ci.upper[i,] <- ul
for(j in 1:length(my.method)){
sig <- length(y[y/n[i]<=ul[j] &amp;amp;amp;amp;amp; y/n[i]>=ll[j]])
samp.prob<-dnorm(1:10,mean = 4.5,sd = 2)
ratings <- sample(1:10, 36, replace = T, prob = samp.prob)
hist(ratings)
simple.hist.and.plot(ratings)
library(UsingR)
simple.hist.and.plot(ratings)
simple.hist.and.boxplot(ratings)
library(date)
install.packages("date")
library(chron)
install.packages("cnron")
install.packages("chron")
library(date)
library(chron)
dates<-as.data.frame(cbind(c(1,3,6,11,4,12,5,3),
c(30,14,NA,NA,16,NA,20,31),
c(1980, 1980, 1980, 1983,1983, 1983, 1986, 1980),
c(2, NA, NA, NA, NA, 12, 4, NA),
c(2, NA, NA, NA, NA, NA, 29, NA),
c(1980, NA, NA, 1985, NA, 1983, 1987, NA)))
colnames(dates)<-c("birth_month", "birth_day", "birth_year", "death_month", "death_day", "death_year")
dates$DOB<-ISOdate(dates$birth_year, dates$birth_month, dates$birth_day)
class(dates$DOB)
dates$DOB<-strptime(dates$DOB, format="%Y-%m-%d")
dates$DOD<-strptime(ISOdate(dates$death_year, dates$death_month, dates$death_day), format="%Y-%m-%d")
##intervals in time, calculate age at death
dates$Age.atdeath<-difftime(dates$DOD, dates$DOB, unit="days")
dates$Age.atdeath
mydata<-read.csv(file="./data/mydata_gettingdatainR.csv")
mydata
class(mydata$SBP)
mydata$SBP<-as.numeric(ifelse(mydata$SBP==".", NA, mydata$SBP))
install.packages("RJSONIO")
library(RJSONIO)
RawData <- fromJSON("https://data.cityofchicago.org/api/views/xzkq-xp2w/rows.json?accessType=DOWNLOAD")
Data <- RawData$data
employeeNames <- sapply(Data, function(x) x[[9]])
head(employeeNames)
install.packages('gdata')
library(gdata) # necessary for trim
grabinfo  <- function(var) {
print(paste("Variable", var, sep=" ")) # for aesthetics: tells you which variables have been processed
sapply(Data, function(x) returnData(x,var)) # the dataset "Data" is hardcoded here and is input as parameter "x"
}
returnData <- function(x, var) {
if (!is.null( x[[var]] )) {
return ( trim( x[[var]] ))
} else {
return(NA)
}
}
df <- data.frame(sapply(1:length(Data[[1]]),grabinfo), stringsAsFactors=FALSE)
head(df) # Just checking that things are working again
names(df) <- sapply(1:12,function(x) RawData[['meta']][['view']][['columns']][[x]][['name']])
df$`Employee Annual Salary` <- as.numeric(df$`Employee Annual Salary`) # change the variable to numeric
View(df)
library(RJSONIO)
foodMarketsRaw<-fromJSON("https://data.ny.gov/api/views/9a8c-vfzj/rows.json?accessType=DOWNLOAD")
foodMarkets<-foodMarketsRaw[['data']]
head(foodMarkets)
foodMarkets[[1]][[14]] ## name of food market 1
foodMarkets[[2]][[14]] ## name of food market 2
fmNames<-sapply(foodMarkets, function(x) x[[14]])
head(fmNames)
library(gdata) # for the trim function
grabInfo<-function(var){
print(paste("Variable", var, sep=" "))
sapply(foodMarkets, function(x) returnData(x, var))
}
returnData<-function(x, var){
if(!is.null( x[[var]])){
return( trim(x[[var]]))
}else{
return(NA)
}
}
# do the extraction and assembly
fmDataDF<-data.frame(sapply(1:22, grabInfo), stringsAsFactors=FALSE)
View(fmDataDF)
foodMarkets[[1]][[23]] #geographic info for food market 1
grabGeoInfo<-function(val){
l<- length(foodMarkets[[1]][[val]])
tmp<-lapply(1:l, function(y)
sapply(foodMarkets, function(x){
if(!is.null(x[[val]][[y]])){
return(x[[val]][[y]])
}else{
return(NA)
}
})
)
}
fmDataGeo<-grabGeoInfo(23)
fmDataGeo<-data.frame(do.call("cbind", fmDataGeo), stringsAsFactors=FALSE)
fmDataDF<-cbind(fmDataDF, fmDataGeo)
columns<-foodMarketsRaw[['meta']][['view']][['columns']]
getNames<-function(x){
if(is.null(columns[[x]]$subColumnTypes)){
return(columns[[x]]$name)
}else{
return(columns[[x]]$subColumnTypes)
}
}
fmNames<-unlist(sapply(1:length(columns), getNames))
names(fmDataDF)<-fmNames
head(fmDataDF)
fmDataDF$latitude<-as.numeric(fmDataDF$latitude)
fmDataDF$longitude<-as.numeric(fmDataDF$longitude)
library(rgdal)
library(ggplot2)
state<-readOGR("./data/json_from_R", layer="nys")
getwd()
?readOGR
state<-readOGR("./data/", layer="nys")
state<-readOGR("./data", layer="nys")
fmDataDF<-fmDataDF[!is.na(fmDataDF$latitude) & !is.na(fmDataDF$longitude),]
fmDataDF[["Square Footage"]]<-as.numeric(fmDataDF[["Square Footage"]])
write.csv(fmDataDF[,c("Estab Type", "DBA Name", "latitude", "longitude", "Square Footage")],
".data/foodmarkets.csv", row.names=FALSE)
data <- airquality
data[4:10,3] <- rep(NA,7)
data[1:5,4] <- NA
View(data)
data <- data[-c(5,6)]
summary(data)
pMiss <- function(x){sum(is.na(x))/length(x)*100}
apply(data,2,pMiss)
apply(data,1,pMiss)
library(mice)
install.packages("mice")
library(mice)
md.pattern(data)
library(VIM)
install.packages("VIM")
library(VIM)
aggr_plot <- aggr(data, col=c('navyblue','red'), numbers=TRUE, sortVars=TRUE, labels=names(data), cex.axis=.7, gap=3, ylab=c("Histogram of missing data","Pattern"))
marginplot(data[c(1,2)])
tempData <- mice(data,m=5,maxit=50,meth='pmm',seed=500)
summary(tempData)
tempData$imp$Ozone
tempData$meth
completedData <- complete(tempData,1)
xyplot(tempData,Ozone ~ Wind+Temp+Solar.R,pch=18,cex=1)
install.packages("lattice")
library("lattice", lib.loc="~/R/win-library/3.2")
xyplot(tempData,Ozone ~ Wind+Temp+Solar.R,pch=18,cex=1)
densityplot(tempData)
stripplot(tempData, pch = 20, cex = 1.2)
modelFit1 <- with(tempData,lm(Temp~ Ozone+Solar.R+Wind))
summary(pool(modelFit1))
tempData2 <- mice(data,m=50,seed=245435)
modelFit2 <- with(tempData2,lm(Temp~ Ozone+Solar.R+Wind))
summary(pool(modelFit2))
head(tempData$imp$Ozone, n=15)
data <- airquality
data[4:10,3] <- rep(NA,7)
data[1:5,4] <- NA
data <- data[-c(5,6)]
pMiss <- function(x){sum(is.na(x))/length(x)*100}
apply(data,2,pMiss)
apply(data,1,pMiss)
tempData <- mice(data,m=5,maxit=50,meth='pmm',seed=500)
library(mice)
tempData <- mice(data,m=5,maxit=50,meth='pmm',seed=500)
ggplot_missing(tempData)
library(reshape2)
library(ggplot2)
ggplot_missing <- function(x){
x %>%
is.na %>%
melt %>%
ggplot(data = .,
aes(x = Var2,
y = Var1)) +
geom_raster(aes(fill = value)) +
scale_fill_grey(name = "",
labels = c("Present","Missing")) +
theme_minimal() +
theme(axis.text.x  = element_text(angle=45, vjust=0.5)) +
labs(x = "Variables in Dataset",
y = "Rows / observations")
}
ggplot_missing(tempData)
library(magrittr)
ggplot_missing(tempData)
install.packages("ExploringData")
require(ggplot2)
data(diamonds)
is.na(diamonds$price) <- diamonds$cut == "Ideal"
is.na(diamonds$cut) <- (runif(nrow(diamonds)) > 0.8)
tableplot(diamonds)
require(tableplot)
install.packages("tableplot")
require(tableplot)
tableplot(diamonds)
require(tabplot)
install.packages("tabplot")
require(tabplot)
tableplot(diamonds)
tableplot(diamonds, select = c(carat, price, cut, color, clarity), sortCol = price)
